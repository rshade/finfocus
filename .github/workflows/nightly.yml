name: Nightly Tests

on:
  schedule:
    # Run at 2 AM UTC every day
    - cron: '0 2 * * *'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      run_e2e:
        description: 'Run E2E tests (requires AWS credentials)'
        required: false
        default: 'true'
        type: boolean
      run_integration:
        description: 'Run integration tests'
        required: false
        default: 'true'
        type: boolean
      run_analyzer:
        description: 'Run Analyzer E2E tests'
        required: false
        default: 'true'
        type: boolean
      fuzz_duration:
        description: 'Fuzz testing duration (e.g., 1h, 6h)'
        required: false
        default: '6h'

permissions:
  contents: read
  issues: write
  checks: write
  id-token: write # Required for AWS OIDC authentication

env:
  GOPRIVATE: github.com/rshade/*
  GO_VERSION: '1.25.7'

jobs:
  # Cross-platform test suite
  cross-platform-tests:
    name: Tests (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run tests
        run: go test -v -race ./internal/... ./pkg/...

      - name: Run go vet
        run: go vet ./...

  integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'schedule' || github.event.inputs.run_integration == 'true' }}
    timeout-minutes: 60
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build plugin binaries for integration tests
        run: |
          if [ -d "examples/plugins/aws-example" ]; then
            go build -o bin/aws-example-plugin ./examples/plugins/aws-example
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ secrets.AWS_E2E_ROLE_ARN }}
          aws-region: us-east-1

      - name: Run integration tests
        env:
          AWS_REGION: us-east-1
          AWS_E2E_REGION: us-east-1
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE || 'e2e-test-passphrase' }}
          E2E_TIMEOUT_MINS: '60'
          FINFOCUS_LOG_LEVEL: debug
          FINFOCUS_LOG_FORMAT: text
        run: |
          echo "Running integration tests (including nightly-only tests)..."
          go test -v -timeout 50m -tags nightly ./test/integration/...

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: integration-test-results
          path: |
            test/integration/*.log
          retention-days: 7

  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'schedule' || github.event.inputs.run_e2e == 'true' }}
    timeout-minutes: 120
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install Pulumi CLI
        uses: pulumi/actions@v6
        with:
          pulumi-version: latest

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ secrets.AWS_E2E_ROLE_ARN }}
          aws-region: us-east-1

      - name: Build finfocus binary
        run: make build

      - name: Run E2E tests
        env:
          AWS_REGION: us-east-1
          E2E_REGION: us-east-1
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE || 'e2e-test-passphrase' }}
          E2E_TIMEOUT_MINS: '60'
          FINFOCUS_LOG_LEVEL: debug
          FINFOCUS_LOG_FORMAT: text
          FINFOCUS_BINARY: ${{ github.workspace }}/bin/finfocus
        run: |
          cd test/e2e
          go test -v -tags e2e -timeout 100m ./...

      - name: Upload E2E test results
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: e2e-test-results
          path: |
            test/e2e/*.log
          retention-days: 7

  analyzer-e2e:
    name: Analyzer E2E Tests
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'schedule' || github.event.inputs.run_analyzer == 'true' }}
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install Pulumi CLI
        uses: pulumi/actions@v6
        with:
          pulumi-version: latest

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ secrets.AWS_E2E_ROLE_ARN }}
          aws-region: us-east-1

      - name: Build finfocus binary
        run: make build

      - name: Run Analyzer E2E tests
        env:
          AWS_REGION: us-east-1
          E2E_REGION: us-east-1
          PULUMI_CONFIG_PASSPHRASE: ${{ secrets.PULUMI_CONFIG_PASSPHRASE || 'e2e-test-passphrase' }}
          FINFOCUS_LOG_LEVEL: debug
          FINFOCUS_LOG_FORMAT: text
          FINFOCUS_BINARY: ${{ github.workspace }}/bin/finfocus
        run: |
          cd test/e2e
          go test -v -tags e2e -timeout 20m -run "TestAnalyzer" ./...

      - name: Upload Analyzer E2E test results
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: analyzer-e2e-test-results
          path: |
            test/e2e/*.log
          retention-days: 7

  # Deep fuzzing (Linux only - runs longer)
  deep-fuzz:
    name: Deep Fuzz Testing
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Restore fuzz corpus cache
        uses: actions/cache@v5
        with:
          path: |
            internal/ingest/testdata/fuzz
            internal/spec/testdata/fuzz
          key: fuzz-corpus-deep-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            fuzz-corpus-deep-${{ runner.os }}-
            fuzz-corpus-${{ runner.os }}-

      - name: Run deep JSON fuzz test
        run: |
          DURATION="${{ github.event.inputs.fuzz_duration || '6h' }}"
          echo "Running FuzzJSON for $DURATION"
          go test -fuzz=FuzzJSON -fuzztime=$DURATION ./internal/ingest || true
          go test -fuzz=FuzzPulumiPlanParse -fuzztime=$DURATION ./internal/ingest || true
        timeout-minutes: 420 # 7 hours max

      - name: Run deep YAML fuzz test
        run: |
          DURATION="${{ github.event.inputs.fuzz_duration || '6h' }}"
          echo "Running FuzzYAML for $DURATION"
          go test -fuzz=FuzzYAML -fuzztime=$DURATION ./internal/spec || true
          go test -fuzz=FuzzSpecFilename -fuzztime=$DURATION ./internal/spec || true
        timeout-minutes: 420 # 7 hours max

      - name: Save fuzz corpus cache
        uses: actions/cache/save@v5
        if: always()
        with:
          path: |
            internal/ingest/testdata/fuzz
            internal/spec/testdata/fuzz
          key: fuzz-corpus-deep-${{ runner.os }}-${{ github.sha }}

      - name: Upload fuzz corpus artifacts
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: fuzz-corpus-${{ github.run_id }}
          path: |
            internal/ingest/testdata/fuzz
            internal/spec/testdata/fuzz
          retention-days: 30

  # Cross-platform builds
  cross-platform-builds:
    name: Build (${{ matrix.os }}-${{ matrix.goarch }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            goos: linux
            goarch: amd64
          - os: ubuntu-latest
            goos: linux
            goarch: arm64
          - os: macos-latest
            goos: darwin
            goarch: amd64
          - os: macos-latest
            goos: darwin
            goarch: arm64
          - os: windows-latest
            goos: windows
            goarch: amd64
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        shell: bash
        run: |
          VERSION=$(git describe --tags --always --dirty)
          COMMIT=$(git rev-parse HEAD)
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          BINARY_NAME="finfocus"
          if [ "${GOOS}" = "windows" ]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          mkdir -p dist
          go build -ldflags "-X 'github.com/rshade/finfocus/pkg/version.version=${VERSION}' -X 'github.com/rshade/finfocus/pkg/version.gitCommit=${COMMIT}' -X 'github.com/rshade/finfocus/pkg/version.buildDate=${BUILD_DATE}'" -o dist/${BINARY_NAME} ./cmd/finfocus

      - name: Verify binary
        shell: bash
        run: |
          if [ "${{ matrix.goos }}" = "linux" ] || [ "${{ matrix.goos }}" = "darwin" ]; then
            chmod +x dist/finfocus
            ./dist/finfocus --version || true
          fi

  # Benchmarks (Linux only)
  benchmarks:
    name: Performance Benchmarks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run benchmarks
        run: |
          go test -bench=. -benchmem -benchtime=3s ./test/benchmarks/... 2>&1 | tee benchmark-results.txt

      - name: Upload benchmark results
        uses: actions/upload-artifact@v6
        with:
          name: benchmark-results-${{ github.run_id }}
          path: benchmark-results.txt
          retention-days: 30

  # Post-test AWS resource cleanup
  aws-cleanup:
    name: AWS E2E Cleanup
    runs-on: ubuntu-latest
    needs: [integration, e2e, analyzer-e2e]
    if: always()
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v6
        with:
          role-to-assume: ${{ secrets.AWS_E2E_ROLE_ARN }}
          aws-region: us-east-1

      - name: Clean up E2E AWS resources
        shell: bash
        run: |
          set +e  # Don't fail on individual cleanup errors

          cleanup_region() {
            local REGION="$1"
            echo "=== Cleaning up region: ${REGION} ==="

            # 1. Terminate EC2 instances tagged with e2e-test-*
            mapfile -t INSTANCE_IDS < <(aws ec2 describe-instances \
              --region "${REGION}" \
              --filters "Name=tag:Name,Values=e2e-test-*" "Name=instance-state-name,Values=running,stopped,pending" \
              --query "Reservations[].Instances[].InstanceId" --output text 2>/dev/null | xargs -n1)
            if [ "${#INSTANCE_IDS[@]}" -gt 0 ]; then
              echo "Terminating instances in ${REGION}: ${INSTANCE_IDS[*]}"
              aws ec2 terminate-instances --region "${REGION}" --instance-ids "${INSTANCE_IDS[@]}"
              aws ec2 wait instance-terminated --region "${REGION}" --instance-ids "${INSTANCE_IDS[@]}" || true
            fi

            # 2. Delete detached EBS volumes
            mapfile -t VOLUME_IDS < <(aws ec2 describe-volumes \
              --region "${REGION}" \
              --filters "Name=tag:Name,Values=e2e-test-*" "Name=status,Values=available" \
              --query "Volumes[].VolumeId" --output text 2>/dev/null | xargs -n1)
            if [ "${#VOLUME_IDS[@]}" -gt 0 ]; then
              echo "Deleting volumes in ${REGION}: ${VOLUME_IDS[*]}"
              for VOL in "${VOLUME_IDS[@]}"; do
                aws ec2 delete-volume --region "${REGION}" --volume-id "${VOL}" || true
              done
            fi

            # 3. Delete security groups (non-default)
            mapfile -t SG_IDS < <(aws ec2 describe-security-groups \
              --region "${REGION}" \
              --filters "Name=tag:Name,Values=e2e-test-*" \
              --query "SecurityGroups[?GroupName!='default'].GroupId" --output text 2>/dev/null | xargs -n1)
            if [ "${#SG_IDS[@]}" -gt 0 ]; then
              echo "Deleting security groups in ${REGION}: ${SG_IDS[*]}"
              for SG in "${SG_IDS[@]}"; do
                aws ec2 delete-security-group --region "${REGION}" --group-id "${SG}" || true
              done
            fi

            # 4. Delete subnets
            mapfile -t SUBNET_IDS < <(aws ec2 describe-subnets \
              --region "${REGION}" \
              --filters "Name=tag:Name,Values=e2e-test-*" \
              --query "Subnets[].SubnetId" --output text 2>/dev/null | xargs -n1)
            if [ "${#SUBNET_IDS[@]}" -gt 0 ]; then
              echo "Deleting subnets in ${REGION}: ${SUBNET_IDS[*]}"
              for SUBNET in "${SUBNET_IDS[@]}"; do
                aws ec2 delete-subnet --region "${REGION}" --subnet-id "${SUBNET}" || true
              done
            fi

            # 5. Detach and delete internet gateways
            mapfile -t VPC_IDS < <(aws ec2 describe-vpcs \
              --region "${REGION}" \
              --filters "Name=tag:Name,Values=e2e-test-*,test-vpc" \
              --query "Vpcs[].VpcId" --output text 2>/dev/null | xargs -n1)
            if [ "${#VPC_IDS[@]}" -gt 0 ]; then
              for VPC in "${VPC_IDS[@]}"; do
                mapfile -t IGW_IDS < <(aws ec2 describe-internet-gateways \
                  --region "${REGION}" \
                  --filters "Name=attachment.vpc-id,Values=${VPC}" \
                  --query "InternetGateways[].InternetGatewayId" --output text 2>/dev/null | xargs -n1)
                if [ "${#IGW_IDS[@]}" -gt 0 ]; then
                  for IGW in "${IGW_IDS[@]}"; do
                    echo "Detaching and deleting IGW ${IGW} from VPC ${VPC} in ${REGION}"
                    aws ec2 detach-internet-gateway --region "${REGION}" --internet-gateway-id "${IGW}" --vpc-id "${VPC}" || true
                    aws ec2 delete-internet-gateway --region "${REGION}" --internet-gateway-id "${IGW}" || true
                  done
                fi
              done
            fi

            # 5a. Delete NAT Gateways per VPC (hold ENIs in subnets; must precede VPC deletion)
            if [ "${#VPC_IDS[@]}" -gt 0 ]; then
              for VPC in "${VPC_IDS[@]}"; do
                mapfile -t NAT_IDS < <(aws ec2 describe-nat-gateways \
                  --region "${REGION}" \
                  --filter "Name=vpc-id,Values=${VPC}" "Name=state,Values=available,pending,failed" \
                  --query "NatGateways[].NatGatewayId" --output text 2>/dev/null | xargs -n1)
                if [ "${#NAT_IDS[@]}" -gt 0 ]; then
                  for NAT in "${NAT_IDS[@]}"; do
                    echo "Deleting NAT Gateway ${NAT} in VPC ${VPC} (${REGION})"
                    aws ec2 delete-nat-gateway --region "${REGION}" --nat-gateway-id "${NAT}" || true
                  done
                  # Wait for NAT gateways to fully delete before proceeding
                  for NAT in "${NAT_IDS[@]}"; do
                    echo "Waiting for NAT Gateway ${NAT} to delete..."
                    aws ec2 wait nat-gateway-deleted --region "${REGION}" \
                      --nat-gateway-ids "${NAT}" 2>/dev/null || true
                  done
                fi
              done
            fi

            # 5b. Release Elastic IPs tagged with e2e-test-* (disassociated EIPs still incur charges)
            mapfile -t EIP_ALLOCS < <(aws ec2 describe-addresses \
              --region "${REGION}" \
              --filters "Name=tag:Name,Values=e2e-test-*" \
              --query "Addresses[].AllocationId" --output text 2>/dev/null | xargs -n1)
            if [ "${#EIP_ALLOCS[@]}" -gt 0 ]; then
              for ALLOC in "${EIP_ALLOCS[@]}"; do
                echo "Releasing Elastic IP ${ALLOC} in ${REGION}"
                aws ec2 release-address --region "${REGION}" --allocation-id "${ALLOC}" || true
              done
            fi

            # 6. Delete VPCs
            if [ "${#VPC_IDS[@]}" -gt 0 ]; then
              echo "Deleting VPCs in ${REGION}: ${VPC_IDS[*]}"
              for VPC in "${VPC_IDS[@]}"; do
                aws ec2 delete-vpc --region "${REGION}" --vpc-id "${VPC}" || true
              done
            fi

            echo "=== Cleanup complete for ${REGION} ==="
          }

          # Clean up all regions used by E2E tests
          for REGION in us-east-1 eu-west-1 ap-northeast-1; do
            cleanup_region "${REGION}"
          done

  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [cross-platform-tests, integration, e2e, analyzer-e2e, deep-fuzz, cross-platform-builds, benchmarks, aws-cleanup]
    if: always() && github.event_name == 'schedule' && failure()
    steps:
      - name: Create failure issue
        uses: actions/github-script@v8
        with:
          script: |
            const title = `Nightly test failure - ${new Date().toISOString().split('T')[0]}`;
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            // Check if an issue already exists for today
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'nightly-failure',
              state: 'open'
            });

            const todayIssue = existingIssues.data.find(issue =>
              issue.title.includes(new Date().toISOString().split('T')[0])
            );

            if (todayIssue) {
              // Add comment to existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: todayIssue.number,
                body: `Another nightly run failed: ${runUrl}`
              });
            } else {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: `## Nightly Test Failure\n\nThe nightly test run has failed.\n\n**Run URL:** ${runUrl}\n\nPlease investigate and fix the failing tests.`,
                labels: ['nightly-failure', 'bug']
              });
            }
