package cache

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"sort"
	"strings"
)

// KeyParams represents parameters used to generate a cache key.
// This ensures deterministic cache key generation for consistent lookups.
type KeyParams struct {
	// Operation is the operation type (e.g., "projected_cost", "actual_cost", "recommendations").
	Operation string `json:"operation"`

	// Provider is the cloud provider (e.g., "aws", "gcp", "azure").
	Provider string `json:"provider"`

	// ResourceTypes is a list of resource types being queried.
	ResourceTypes []string `json:"resource_types,omitempty"`

	// Filters contains additional query filters (e.g., tags, date ranges).
	Filters map[string]string `json:"filters,omitempty"`

	// Pagination contains pagination parameters that affect the query.
	Pagination *PaginationKeyParams `json:"pagination,omitempty"`
}

// PaginationKeyParams contains pagination-specific parameters for cache key generation.
// These parameters are optional and only included if pagination affects the query result.
type PaginationKeyParams struct {
	// Limit is the maximum number of results.
	Limit int `json:"limit,omitempty"`

	// Offset is the result offset.
	Offset int `json:"offset,omitempty"`

	// SortField is the field used for sorting.
	SortField string `json:"sort_field,omitempty"`

	// SortOrder is the sort direction.
	SortOrder string `json:"sort_order,omitempty"`
}

// GenerateKey creates a deterministic SHA256-based cache key from parameters.
// The key is generated by JSON-serializing the parameters and hashing the result.
// This ensures identical parameters always produce the same cache key.
func GenerateKey(params KeyParams) (string, error) {
	// Normalize parameters for deterministic key generation
	normalized := normalizeKeyParams(params)

	// Serialize to JSON
	data, err := json.Marshal(normalized)
	if err != nil {
		return "", fmt.Errorf("failed to marshal key params: %w", err)
	}

	// Generate SHA256 hash
	hash := sha256.Sum256(data)
	return hex.EncodeToString(hash[:]), nil
}

// GenerateSimpleKey creates a cache key from a simple string representation.
// This is useful for ad-hoc caching scenarios where a full KeyParams struct is overkill.
func GenerateSimpleKey(operation, provider string, additionalParams ...string) string {
	parts := []string{operation, provider}
	parts = append(parts, additionalParams...)

	// Join and hash
	combined := strings.Join(parts, ":")
	hash := sha256.Sum256([]byte(combined))
	return hex.EncodeToString(hash[:])
}

// GenerateKeyFromQuery creates a cache key from a query string.
// This is useful for caching arbitrary query results.
func GenerateKeyFromQuery(query string) string {
	hash := sha256.Sum256([]byte(query))
	return hex.EncodeToString(hash[:])
}

// normalizeKeyParams ensures deterministic key generation by:
// - Sorting resource types alphabetically.
// - Sorting filter keys alphabetically.
// - Normalizing string casing for operation and provider.
func normalizeKeyParams(params KeyParams) KeyParams {
	normalized := KeyParams{
		Operation: strings.ToLower(strings.TrimSpace(params.Operation)),
		Provider:  strings.ToLower(strings.TrimSpace(params.Provider)),
		Filters:   make(map[string]string),
	}

	// Sort and copy resource types
	if len(params.ResourceTypes) > 0 {
		normalized.ResourceTypes = make([]string, len(params.ResourceTypes))
		copy(normalized.ResourceTypes, params.ResourceTypes)
		sort.Strings(normalized.ResourceTypes)
	}

	// Sort and copy filters
	if len(params.Filters) > 0 {
		// Sort filter keys for deterministic iteration
		keys := make([]string, 0, len(params.Filters))
		for k := range params.Filters {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, k := range keys {
			normalized.Filters[k] = params.Filters[k]
		}
	}

	// Copy pagination params if present
	if params.Pagination != nil {
		normalized.Pagination = &PaginationKeyParams{
			Limit:     params.Pagination.Limit,
			Offset:    params.Pagination.Offset,
			SortField: params.Pagination.SortField,
			SortOrder: strings.ToLower(params.Pagination.SortOrder),
		}
	}

	return normalized
}

// KeyParamsBuilder provides a fluent interface for building cache key parameters.
type KeyParamsBuilder struct {
	params KeyParams
}

// NewKeyParamsBuilder creates a new builder for cache key parameters.
func NewKeyParamsBuilder(operation, provider string) *KeyParamsBuilder {
	return &KeyParamsBuilder{
		params: KeyParams{
			Operation: operation,
			Provider:  provider,
			Filters:   make(map[string]string),
		},
	}
}

// WithResourceTypes adds resource types to the key parameters.
func (b *KeyParamsBuilder) WithResourceTypes(types ...string) *KeyParamsBuilder {
	b.params.ResourceTypes = append(b.params.ResourceTypes, types...)
	return b
}

// WithFilter adds a filter key-value pair to the key parameters.
func (b *KeyParamsBuilder) WithFilter(key, value string) *KeyParamsBuilder {
	b.params.Filters[key] = value
	return b
}

// WithFilters adds multiple filters to the key parameters.
func (b *KeyParamsBuilder) WithFilters(filters map[string]string) *KeyParamsBuilder {
	for k, v := range filters {
		b.params.Filters[k] = v
	}
	return b
}

// WithPagination adds pagination parameters to the key.
func (b *KeyParamsBuilder) WithPagination(limit, offset int, sortField, sortOrder string) *KeyParamsBuilder {
	b.params.Pagination = &PaginationKeyParams{
		Limit:     limit,
		Offset:    offset,
		SortField: sortField,
		SortOrder: sortOrder,
	}
	return b
}

// Build generates the cache key from the accumulated parameters.
func (b *KeyParamsBuilder) Build() (string, error) {
	return GenerateKey(b.params)
}

// BuildParams returns the accumulated key parameters without generating the key.
func (b *KeyParamsBuilder) BuildParams() KeyParams {
	return b.params
}
