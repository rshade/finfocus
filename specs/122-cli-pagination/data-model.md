# Data Model: Pagination and Performance Optimizations

**Feature**: CLI Pagination and Performance Optimizations
**Branch**: `122-cli-pagination`
**Date**: 2026-01-20

## Overview

This document defines the data structures, entities, and relationships for implementing pagination, caching, batch processing, and virtual scrolling in FinFocus Core.

## Core Entities

### 1. PaginationParams

Request parameters for paginating CLI output.

```go
// PaginationParams captures CLI pagination flags
type PaginationParams struct {
    // Limit restricts the number of returned items (0 = unlimited)
    Limit int

    // Offset skips N items before returning results (0-indexed)
    Offset int

    // Page specifies which page to return (1-indexed, mutually exclusive with Offset)
    // If Page > 0, Offset is calculated as: (Page - 1) * PageSize
    Page int

    // PageSize is the number of items per page (default: 20)
    // Used with Page to calculate Offset
    PageSize int

    // SortBy specifies the field and direction for sorting
    // Format: "field:asc" or "field:desc"
    // Examples: "savings:desc", "cost:asc", "name:asc"
    SortBy string
}

// Validate checks for conflicting or invalid pagination parameters
func (p PaginationParams) Validate() error {
    // Cannot use both Page and Offset
    if p.Page > 0 && p.Offset > 0 {
        return fmt.Errorf("cannot specify both --page and --offset")
    }

    // Page must be >= 1 if specified
    if p.Page < 0 {
        return fmt.Errorf("page must be >= 1, got %d", p.Page)
    }

    // PageSize must be > 0 if Page is specified
    if p.Page > 0 && p.PageSize <= 0 {
        return fmt.Errorf("page-size must be > 0 when using --page")
    }

    // Offset must be >= 0
    if p.Offset < 0 {
        return fmt.Errorf("offset must be >= 0, got %d", p.Offset)
    }

    // Limit must be >= 0
    if p.Limit < 0 {
        return fmt.Errorf("limit must be >= 0, got %d", p.Limit)
    }

    return nil
}

// CalculateOffset computes the actual offset based on Page or Offset
func (p PaginationParams) CalculateOffset() int {
    if p.Page > 0 {
        return (p.Page - 1) * p.PageSize
    }
    return p.Offset
}
```

**Relationships**:
- Used by CLI command handlers to parse flags
- Passed to engine for query execution
- Validated before engine invocation

**Validation Rules**:
- Page and Offset are mutually exclusive
- Page must be >= 1 if specified
- PageSize must be > 0 when using Page
- Offset and Limit must be >= 0

---

### 2. PaginationMeta

Metadata about paginated results (included in JSON output).

```go
// PaginationMeta provides metadata about paginated results
type PaginationMeta struct {
    // Page is the current page number (1-indexed)
    Page int `json:"page"`

    // PageSize is the number of items per page
    PageSize int `json:"page_size"`

    // TotalItems is the total number of items across all pages
    TotalItems int `json:"total_items"`

    // TotalPages is the calculated number of pages (TotalItems / PageSize, rounded up)
    TotalPages int `json:"total_pages"`

    // HasNextPage indicates if there's a page after the current one
    HasNextPage bool `json:"has_next_page"`

    // HasPrevPage indicates if there's a page before the current one
    HasPrevPage bool `json:"has_prev_page"`
}

// NewPaginationMeta creates metadata from params and total count
func NewPaginationMeta(params PaginationParams, totalItems int) PaginationMeta {
    page := params.Page
    if page == 0 {
        page = 1 // Default to page 1 if using offset
    }

    pageSize := params.PageSize
    if pageSize == 0 {
        pageSize = totalItems // Single page if not specified
    }

    totalPages := (totalItems + pageSize - 1) / pageSize // Ceiling division

    return PaginationMeta{
        Page:        page,
        PageSize:    pageSize,
        TotalItems:  totalItems,
        TotalPages:  totalPages,
        HasNextPage: page < totalPages,
        HasPrevPage: page > 1,
    }
}
```

**Relationships**:
- Generated by engine after query execution
- Included in JSON output responses (not in NDJSON streaming mode)
- Used by TUI for pagination controls

**Invariants**:
- Page <= TotalPages (or TotalPages == 0 for empty results)
- HasNextPage == (Page < TotalPages)
- HasPrevPage == (Page > 1)

---

### 3. CacheEntry

Persistent cache entry with TTL expiration.

```go
// CacheEntry represents a cached query result with TTL
type CacheEntry struct {
    // Key is the cache key (SHA256 hash of query parameters)
    Key string `json:"key"`

    // Data is the cached result (opaque JSON payload)
    Data json.RawMessage `json:"data"`

    // Timestamp is when this entry was created
    Timestamp time.Time `json:"timestamp"`

    // TTLSeconds is the time-to-live in seconds
    TTLSeconds int `json:"ttl_seconds"`
}

// IsExpired checks if the cache entry has exceeded its TTL
func (e CacheEntry) IsExpired() bool {
    expiresAt := e.Timestamp.Add(time.Duration(e.TTLSeconds) * time.Second)
    return time.Now().After(expiresAt)
}

// ExpiresAt returns the absolute expiration time
func (e CacheEntry) ExpiresAt() time.Time {
    return e.Timestamp.Add(time.Duration(e.TTLSeconds) * time.Second)
}

// RemainingTTL returns the remaining TTL duration (0 if expired)
func (e CacheEntry) RemainingTTL() time.Duration {
    remaining := time.Until(e.ExpiresAt())
    if remaining < 0 {
        return 0
    }
    return remaining
}
```

**Storage**:
- File path: `~/.finfocus/cache/<sha256(key)>.json`
- Format: JSON with embedded metadata
- Lifecycle: Created on cache write, deleted on expiration or manual clear

**Relationships**:
- Created by CacheStore.Set()
- Read by CacheStore.Get()
- Deleted when IsExpired() returns true

**State Transitions**:
```
[Not Exists] --Set()--> [Valid]
[Valid] --TTL elapsed--> [Expired] --Get()--> [Not Exists]
[Valid] --Clear()--> [Not Exists]
```

---

### 4. VirtualListModel

TUI state for virtual scrolling of large lists.

```go
// VirtualListModel implements Bubble Tea's Model interface for virtual lists
type VirtualListModel struct {
    // Items is the full dataset (kept in memory)
    Items []interface{}

    // Viewport is the Bubble Tea viewport for scroll handling
    Viewport viewport.Model

    // VisibleFrom is the index of the first visible item
    VisibleFrom int

    // VisibleTo is the index of the last visible item
    VisibleTo int

    // Selected is the index of the currently selected item
    Selected int

    // Height is the viewport height in lines
    Height int

    // Width is the viewport width in characters
    Width int

    // RenderFunc is a custom function for rendering individual items
    RenderFunc func(item interface{}, selected bool) string
}

// Update handles Bubble Tea messages (scroll, selection)
func (m VirtualListModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        switch msg.String() {
        case "up", "k":
            if m.Selected > 0 {
                m.Selected--
                m.updateVisibleRange()
            }
        case "down", "j":
            if m.Selected < len(m.Items)-1 {
                m.Selected++
                m.updateVisibleRange()
            }
        case "pgup":
            m.Selected = max(0, m.Selected-m.Height)
            m.updateVisibleRange()
        case "pgdown":
            m.Selected = min(len(m.Items)-1, m.Selected+m.Height)
            m.updateVisibleRange()
        case "home":
            m.Selected = 0
            m.updateVisibleRange()
        case "end":
            m.Selected = len(m.Items) - 1
            m.updateVisibleRange()
        }
    case tea.WindowSizeMsg:
        m.Height = msg.Height
        m.Width = msg.Width
        m.Viewport.Width = msg.Width
        m.Viewport.Height = msg.Height
        m.updateVisibleRange()
    }

    return m, nil
}

// updateVisibleRange calculates which items should be rendered
func (m *VirtualListModel) updateVisibleRange() {
    // Ensure selected item is visible
    if m.Selected < m.VisibleFrom {
        m.VisibleFrom = m.Selected
    }
    if m.Selected >= m.VisibleTo {
        m.VisibleFrom = m.Selected - m.Height + 1
    }

    // Clamp to valid range
    m.VisibleFrom = max(0, m.VisibleFrom)
    m.VisibleTo = min(len(m.Items)-1, m.VisibleFrom+m.Height-1)
}

// View renders only visible rows
func (m VirtualListModel) View() string {
    if len(m.Items) == 0 {
        return lipgloss.NewStyle().Foreground(lipgloss.Color("8")).
            Render("No items")
    }

    var rows []string
    for i := m.VisibleFrom; i <= m.VisibleTo && i < len(m.Items); i++ {
        row := m.RenderFunc(m.Items[i], i == m.Selected)
        rows = append(rows, row)
    }

    return m.Viewport.View(lipgloss.JoinVertical(lipgloss.Left, rows...))
}
```

**Relationships**:
- Managed by TUI list views
- Integrates with Bubble Tea's Update/View lifecycle
- Uses RenderFunc for custom item rendering

**Performance Characteristics**:
- Memory: O(n) for full dataset, O(viewport_height) for rendering
- Render time: O(viewport_height) regardless of total items
- Scroll latency: <16ms per frame (60fps)

---

### 5. BatchProgress

Progress tracking for batch processing operations.

```go
// BatchProgress tracks the progress of batch operations
type BatchProgress struct {
    // Current is the number of items processed so far
    Current int

    // Total is the total number of items to process
    Total int

    // StartTime is when batch processing started
    StartTime time.Time

    // OnProgress is an optional callback invoked after each batch
    // Signature: func(current int, total int)
    OnProgress func(current, total int)
}

// NewBatchProgress creates a new progress tracker
func NewBatchProgress(total int, callback func(int, int)) BatchProgress {
    return BatchProgress{
        Current:    0,
        Total:      total,
        StartTime:  time.Now(),
        OnProgress: callback,
    }
}

// Update increments the current count and calls the progress callback
func (p *BatchProgress) Update(processed int) {
    p.Current += processed
    if p.OnProgress != nil {
        p.OnProgress(p.Current, p.Total)
    }
}

// PercentComplete returns the completion percentage (0-100)
func (p BatchProgress) PercentComplete() float64 {
    if p.Total == 0 {
        return 100.0
    }
    return (float64(p.Current) / float64(p.Total)) * 100.0
}

// EstimatedTimeRemaining estimates time to completion based on current rate
func (p BatchProgress) EstimatedTimeRemaining() time.Duration {
    if p.Current == 0 {
        return 0
    }

    elapsed := time.Since(p.StartTime)
    rate := float64(p.Current) / elapsed.Seconds() // items per second
    remaining := p.Total - p.Current

    if rate == 0 {
        return 0
    }

    return time.Duration(float64(remaining)/rate) * time.Second
}

// FormatProgress returns a human-readable progress string
// Example: "Processing resources... [300/1000] (30%)"
func (p BatchProgress) FormatProgress() string {
    return fmt.Sprintf("Processing resources... [%d/%d] (%.0f%%)",
        p.Current, p.Total, p.PercentComplete())
}
```

**Relationships**:
- Created by batch processor
- Updated after each batch completion
- Used by CLI spinner and TUI progress bars

**Lifecycle**:
```
[Created] --Process batch--> [Updated] --Repeat--> [Complete (Current == Total)]
```

---

## Configuration Schema

### Cache Configuration

```yaml
# ~/.finfocus/config.yaml
cache:
  # Enable or disable caching (default: true)
  enabled: true

  # TTL in seconds for cached results (default: 3600 = 1 hour)
  ttl_seconds: 3600

  # Cache directory (default: ~/.finfocus/cache)
  directory: ~/.finfocus/cache

  # Maximum cache size in MB (default: 100)
  # Oldest entries are evicted when limit is exceeded
  max_size_mb: 100
```

**Configuration Precedence**:
1. CLI flag: `--cache-ttl 7200`
2. Environment variable: `FINFOCUS_CACHE_TTL_SECONDS=7200`
3. Config file: `cache.ttl_seconds: 7200`
4. Default: `3600` (1 hour)

---

## Entity Relationships

```
┌──────────────────┐
│ CLI Command      │
│ (cobra.Command)  │
└────────┬─────────┘
         │ creates
         ▼
┌──────────────────┐
│ PaginationParams │
└────────┬─────────┘
         │ passes to
         ▼
┌──────────────────┐      generates      ┌──────────────────┐
│ Engine           │──────────────────────>│ PaginationMeta   │
│ (cost calc)      │                       │ (in response)    │
└────────┬─────────┘                       └──────────────────┘
         │ checks
         ▼
┌──────────────────┐
│ CacheStore       │
│ (file-based)     │
└────────┬─────────┘
         │ stores/retrieves
         ▼
┌──────────────────┐
│ CacheEntry       │
│ (JSON files)     │
└──────────────────┘

         ┌──────────────────┐
         │ TUI Application  │
         └────────┬─────────┘
                  │ manages
                  ▼
         ┌──────────────────┐
         │ VirtualListModel │
         └────────┬─────────┘
                  │ renders subset
                  ▼
         ┌──────────────────┐
         │ Items (full set) │
         └──────────────────┘

┌──────────────────┐
│ BatchProcessor   │
└────────┬─────────┘
         │ updates
         ▼
┌──────────────────┐
│ BatchProgress    │
└────────┬─────────┘
         │ formats
         ▼
┌──────────────────┐
│ CLI Progress     │
│ Spinner/Bar      │
└──────────────────┘
```

---

## Validation Rules Summary

| Entity | Field | Rule |
|--------|-------|------|
| PaginationParams | Page | >= 1 if specified; mutually exclusive with Offset |
| PaginationParams | Offset | >= 0 |
| PaginationParams | Limit | >= 0 (0 = unlimited) |
| PaginationParams | PageSize | > 0 if Page is specified |
| PaginationMeta | Page | <= TotalPages (or TotalPages == 0) |
| PaginationMeta | TotalPages | (TotalItems + PageSize - 1) / PageSize |
| CacheEntry | TTLSeconds | > 0 |
| CacheEntry | Timestamp | Must be in the past |
| VirtualListModel | VisibleFrom | 0 <= VisibleFrom <= len(Items) |
| VirtualListModel | VisibleTo | VisibleFrom <= VisibleTo < len(Items) |
| VirtualListModel | Selected | 0 <= Selected < len(Items) |
| BatchProgress | Current | 0 <= Current <= Total |

---

## Next Steps

This data model informs the contract definitions (Go interfaces) and implementation tasks. All entities have been designed to support:
- Constitution principle VI (no TODOs/stubs)
- Test-driven development (80%+ coverage)
- Cross-platform compatibility (pure Go, no platform-specific types)

See [contracts/](./contracts/) for Go interface definitions using these entities.
